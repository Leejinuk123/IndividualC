||배열 |리스트|
|-----|:-----:|:-----:|
|메모리 할당 효율|| O|
|데이터 저장 값|O| |
|중간 값 추가/삭제 용이|| O| 

상황에 따라 최적의 자료구조 사용
> ## 1. 리스트
```c
#include <stdio.h>
#include <stdlib.h>
typedef struct list {
	int d;
	struct list* p;
} LIST;
LIST* root = NULL;
LIST* last = NULL;
void AddList(int a) {
	LIST* r = (LIST*)malloc(sizeof(LIST));
	r->d = a;
	r->p = NULL;
	if (root == NULL) root = r;
	else           last->p = r;
	last = r;
}
int main(void) {
	AddList(35);
	AddList(40);
	AddList(45);
	while (root) {
		printf("%d\n", root->d);
		root = root->p;
	}
}
```  
![제목 없음](https://user-images.githubusercontent.com/50895677/68186413-6e072100-ffe7-11e9-8784-c858e1e9332c.png)     
> ## 2. 트리
```c
#include <stdlib.h>               /* malloc */
typedef struct Tree {
    struct Tr *l, *r;
    int d;
} T;
void print(T* p){
   printf("%d\n", p->d);
   if(p->l) print(p->l);
   if(p->r) print(p->r);    
}
T* mem(){
 T* p=(T*)malloc(sizeof(T));
 p->l=p->r=NULL;
 return(p);
}
int main(void){
    T *r, *r1, *r2, *l1;
    l1= (T*)mem(); l1->d=3; 
    r2= (T*)mem(); r2->d=8; 
    r1= (T*)mem(); r1->d=7; r1->r=r2;
    r= (T*)mem(); r->d=5; r->l=l1;  r->r=r1;
    print(r);
}
```
